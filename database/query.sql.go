// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package database

import (
	"context"
	"database/sql"
)

const assignSubjectAccess = `-- name: AssignSubjectAccess :exec
INSERT INTO tbl_subjects_access (
    school_id,
    class_id,
    subject_id
) VALUES (
    ?,
    ?,
    ?
)
`

type AssignSubjectAccessParams struct {
	SchoolID  int64
	ClassID   int64
	SubjectID int64
}

func (q *Queries) AssignSubjectAccess(ctx context.Context, arg AssignSubjectAccessParams) error {
	_, err := q.db.ExecContext(ctx, assignSubjectAccess, arg.SchoolID, arg.ClassID, arg.SubjectID)
	return err
}

const assignTeacherToSubject = `-- name: AssignTeacherToSubject :exec
INSERT INTO tbl_subjects_teacher_access (
    school_id,
    teacher_id,
    subject_id
) VALUES (
    ?,
    ?,
    ?
)
`

type AssignTeacherToSubjectParams struct {
	SchoolID  int64
	TeacherID int64
	SubjectID int64
}

func (q *Queries) AssignTeacherToSubject(ctx context.Context, arg AssignTeacherToSubjectParams) error {
	_, err := q.db.ExecContext(ctx, assignTeacherToSubject, arg.SchoolID, arg.TeacherID, arg.SubjectID)
	return err
}

const createAuthLog = `-- name: CreateAuthLog :execresult
INSERT INTO tbl_auth_logs (
    user_id,
    client_ip,
    client_useragent,
    school_id
) VALUES (
    ?,
    ?,
    ?,
    ?
)
`

type CreateAuthLogParams struct {
	UserID          int64
	ClientIp        string
	ClientUseragent string
	SchoolID        int64
}

func (q *Queries) CreateAuthLog(ctx context.Context, arg CreateAuthLogParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createAuthLog,
		arg.UserID,
		arg.ClientIp,
		arg.ClientUseragent,
		arg.SchoolID,
	)
}

const createUserAccess = `-- name: CreateUserAccess :execresult
INSERT INTO tbl_users_access (
    user_id,
    school_id,
    is_student,
    is_admin,
    is_teacher
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateUserAccessParams struct {
	UserID    int64
	SchoolID  int64
	IsStudent int32
	IsAdmin   int32
	IsTeacher int32
}

func (q *Queries) CreateUserAccess(ctx context.Context, arg CreateUserAccessParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUserAccess,
		arg.UserID,
		arg.SchoolID,
		arg.IsStudent,
		arg.IsAdmin,
		arg.IsTeacher,
	)
}

const deactiveCurrentSemester = `-- name: DeactiveCurrentSemester :exec
UPDATE tbl_semesters SET is_active = 0
WHERE is_active = 1 AND school_id = ?
`

func (q *Queries) DeactiveCurrentSemester(ctx context.Context, schoolID int64) error {
	_, err := q.db.ExecContext(ctx, deactiveCurrentSemester, schoolID)
	return err
}

const deassignSubjectAccess = `-- name: DeassignSubjectAccess :exec
DELETE FROM tbl_subjects_access
WHERE class_id = ?
    AND subject_id = ?
    AND school_id = ?
`

type DeassignSubjectAccessParams struct {
	ClassID   int64
	SubjectID int64
	SchoolID  int64
}

func (q *Queries) DeassignSubjectAccess(ctx context.Context, arg DeassignSubjectAccessParams) error {
	_, err := q.db.ExecContext(ctx, deassignSubjectAccess, arg.ClassID, arg.SubjectID, arg.SchoolID)
	return err
}

const deassignTeacherFromSubject = `-- name: DeassignTeacherFromSubject :exec
DELETE FROM tbl_subjects_teacher_access
WHERE
    teacher_id = ?
AND
    subject_id = ?
AND
    school_id = ?
`

type DeassignTeacherFromSubjectParams struct {
	TeacherID int64
	SubjectID int64
	SchoolID  int64
}

func (q *Queries) DeassignTeacherFromSubject(ctx context.Context, arg DeassignTeacherFromSubjectParams) error {
	_, err := q.db.ExecContext(ctx, deassignTeacherFromSubject, arg.TeacherID, arg.SubjectID, arg.SchoolID)
	return err
}

const deleteMajorById = `-- name: DeleteMajorById :exec
DELETE FROM tbl_majors WHERE id = ?
`

func (q *Queries) DeleteMajorById(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMajorById, id)
	return err
}

const deleteSemesterById = `-- name: DeleteSemesterById :execresult
DELETE FROM tbl_semesters as s
WHERE s.id = ? AND s.school_id = ? AND s.is_active = 0
`

type DeleteSemesterByIdParams struct {
	ID       int64
	SchoolID int64
}

func (q *Queries) DeleteSemesterById(ctx context.Context, arg DeleteSemesterByIdParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteSemesterById, arg.ID, arg.SchoolID)
}

const deleteStudent = `-- name: DeleteStudent :exec
DELETE FROM tbl_users_students
WHERE id = ?
`

func (q *Queries) DeleteStudent(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteStudent, id)
	return err
}

const deleteTeacher = `-- name: DeleteTeacher :exec
DELETE FROM tbl_users_teachers
WHERE id = ?
`

func (q *Queries) DeleteTeacher(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTeacher, id)
	return err
}

const deleteUserAccess = `-- name: DeleteUserAccess :exec
DELETE FROM tbl_users_access WHERE id = ?
`

func (q *Queries) DeleteUserAccess(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserAccess, id)
	return err
}

const deleteUserAccessByUserId = `-- name: DeleteUserAccessByUserId :exec
DELETE FROM tbl_users_access WHERE user_id = ?
`

func (q *Queries) DeleteUserAccessByUserId(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserAccessByUserId, userID)
	return err
}

const getActiveSemester = `-- name: GetActiveSemester :one
SELECT s.id, s.name, s.cycle, s.year, s.is_active, s.school_id, s.created_at, s.updated_at, ss.id, ss.name, ss.short_code, ss.school_national_id, ss.is_active, ss.address, ss.latitude, ss.longitude, ss.headmaster_name, ss.headmaster_id, ss.website, ss.email, ss.logo_url, ss.app_name, ss.created_at, ss.updated_at FROM tbl_semesters as s
INNER JOIN tbl_schools as ss ON ss.id = s.school_id
WHERE s.is_active = 1 AND s.school_id = ?
LIMIT 1
`

type GetActiveSemesterRow struct {
	Semester Semester
	School   School
}

func (q *Queries) GetActiveSemester(ctx context.Context, schoolID int64) (GetActiveSemesterRow, error) {
	row := q.db.QueryRowContext(ctx, getActiveSemester, schoolID)
	var i GetActiveSemesterRow
	err := row.Scan(
		&i.Semester.ID,
		&i.Semester.Name,
		&i.Semester.Cycle,
		&i.Semester.Year,
		&i.Semester.IsActive,
		&i.Semester.SchoolID,
		&i.Semester.CreatedAt,
		&i.Semester.UpdatedAt,
		&i.School.ID,
		&i.School.Name,
		&i.School.ShortCode,
		&i.School.SchoolNationalID,
		&i.School.IsActive,
		&i.School.Address,
		&i.School.Latitude,
		&i.School.Longitude,
		&i.School.HeadmasterName,
		&i.School.HeadmasterID,
		&i.School.Website,
		&i.School.Email,
		&i.School.LogoUrl,
		&i.School.AppName,
		&i.School.CreatedAt,
		&i.School.UpdatedAt,
	)
	return i, err
}

const getClassByName = `-- name: GetClassByName :one
SELECT id, name, grade_level, students_count, major_id, semester_id, school_id, homeroom_teacher_id, created_at, updated_at FROM tbl_classes
WHERE name LIKE ?
LIMIT 1
`

func (q *Queries) GetClassByName(ctx context.Context, name string) (Class, error) {
	row := q.db.QueryRowContext(ctx, getClassByName, name)
	var i Class
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.GradeLevel,
		&i.StudentsCount,
		&i.MajorID,
		&i.SemesterID,
		&i.SchoolID,
		&i.HomeroomTeacherID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMajorById = `-- name: GetMajorById :one
SELECT id, name, short_code, school_id, created_at, updated_at FROM tbl_majors
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetMajorById(ctx context.Context, id int64) (Major, error) {
	row := q.db.QueryRowContext(ctx, getMajorById, id)
	var i Major
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ShortCode,
		&i.SchoolID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMajorByShortCode = `-- name: GetMajorByShortCode :one
SELECT id, name, short_code, school_id, created_at, updated_at FROM tbl_majors
WHERE school_id = ? AND short_code = ?
LIMIT 1
`

type GetMajorByShortCodeParams struct {
	SchoolID  int64
	ShortCode string
}

func (q *Queries) GetMajorByShortCode(ctx context.Context, arg GetMajorByShortCodeParams) (Major, error) {
	row := q.db.QueryRowContext(ctx, getMajorByShortCode, arg.SchoolID, arg.ShortCode)
	var i Major
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ShortCode,
		&i.SchoolID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSchoolById = `-- name: GetSchoolById :one
SELECT id, name, short_code, school_national_id, is_active, address, latitude, longitude, headmaster_name, headmaster_id, website, email, logo_url, app_name, created_at, updated_at FROM tbl_schools
WHERE id = ? LIMIT 1
`

func (q *Queries) GetSchoolById(ctx context.Context, schoolID int64) (School, error) {
	row := q.db.QueryRowContext(ctx, getSchoolById, schoolID)
	var i School
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ShortCode,
		&i.SchoolNationalID,
		&i.IsActive,
		&i.Address,
		&i.Latitude,
		&i.Longitude,
		&i.HeadmasterName,
		&i.HeadmasterID,
		&i.Website,
		&i.Email,
		&i.LogoUrl,
		&i.AppName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSemesterById = `-- name: GetSemesterById :one



SELECT s.id, s.name, s.cycle, s.year, s.is_active, s.school_id, s.created_at, s.updated_at, ss.id, ss.name, ss.short_code, ss.school_national_id, ss.is_active, ss.address, ss.latitude, ss.longitude, ss.headmaster_name, ss.headmaster_id, ss.website, ss.email, ss.logo_url, ss.app_name, ss.created_at, ss.updated_at FROM tbl_semesters as s
INNER JOIN tbl_schools as ss ON ss.id = s.school_id
WHERE s.id = ? AND s.school_id = ?
LIMIT 1
`

type GetSemesterByIdParams struct {
	ID       int64
	SchoolID int64
}

type GetSemesterByIdRow struct {
	Semester Semester
	School   School
}

// ======================= END TABLE SCHOOLS ============================ --
// ======================= TABLE SEMESTERS ============================ --
func (q *Queries) GetSemesterById(ctx context.Context, arg GetSemesterByIdParams) (GetSemesterByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getSemesterById, arg.ID, arg.SchoolID)
	var i GetSemesterByIdRow
	err := row.Scan(
		&i.Semester.ID,
		&i.Semester.Name,
		&i.Semester.Cycle,
		&i.Semester.Year,
		&i.Semester.IsActive,
		&i.Semester.SchoolID,
		&i.Semester.CreatedAt,
		&i.Semester.UpdatedAt,
		&i.School.ID,
		&i.School.Name,
		&i.School.ShortCode,
		&i.School.SchoolNationalID,
		&i.School.IsActive,
		&i.School.Address,
		&i.School.Latitude,
		&i.School.Longitude,
		&i.School.HeadmasterName,
		&i.School.HeadmasterID,
		&i.School.Website,
		&i.School.Email,
		&i.School.LogoUrl,
		&i.School.AppName,
		&i.School.CreatedAt,
		&i.School.UpdatedAt,
	)
	return i, err
}

const getStudentById = `-- name: GetStudentById :one
SELECT student.id, student.name, student.national_student_id, student.school_student_id, student.religion, student.user_id, student.school_id, student.class_id, student.semester_id, student.created_at, student.updated_at, user.id, user.name, user.is_active, user.email, user.password, user.user_access_id, user.user_student_id, user.user_teacher_id, user.school_id, user.created_at, user.updated_at, class.id, class.name, class.grade_level, class.students_count, class.major_id, class.semester_id, class.school_id, class.homeroom_teacher_id, class.created_at, class.updated_at
FROM tbl_users_students as student
LEFT JOIN tbl_users AS user
    ON user.user_student_id = student.id
LEFT JOIN tbl_classes AS class
    ON class.id = student.class_id
WHERE student.school_id = ?
    AND student.semester_id = ?
    AND student.id = ?
LIMIT 1
`

type GetStudentByIdParams struct {
	SchoolID   int64
	SemesterID int64
	ID         int64
}

type GetStudentByIdRow struct {
	Student Student
	User    User
	Class   Class
}

func (q *Queries) GetStudentById(ctx context.Context, arg GetStudentByIdParams) (GetStudentByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getStudentById, arg.SchoolID, arg.SemesterID, arg.ID)
	var i GetStudentByIdRow
	err := row.Scan(
		&i.Student.ID,
		&i.Student.Name,
		&i.Student.NationalStudentID,
		&i.Student.SchoolStudentID,
		&i.Student.Religion,
		&i.Student.UserID,
		&i.Student.SchoolID,
		&i.Student.ClassID,
		&i.Student.SemesterID,
		&i.Student.CreatedAt,
		&i.Student.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.IsActive,
		&i.User.Email,
		&i.User.Password,
		&i.User.UserAccessID,
		&i.User.UserStudentID,
		&i.User.UserTeacherID,
		&i.User.SchoolID,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.Class.ID,
		&i.Class.Name,
		&i.Class.GradeLevel,
		&i.Class.StudentsCount,
		&i.Class.MajorID,
		&i.Class.SemesterID,
		&i.Class.SchoolID,
		&i.Class.HomeroomTeacherID,
		&i.Class.CreatedAt,
		&i.Class.UpdatedAt,
	)
	return i, err
}

const getSubjectById = `-- name: GetSubjectById :one
SELECT t.id, t.name, t.short_code, t.is_active, t.is_universal, t.major_id, t.school_id, t.semester_id, t.created_at, t.updated_at, sta.id, sta.subject_id, sta.school_id, sta.teacher_id FROM tbl_subjects as t
LEFT JOIN tbl_subjects_access as sa
    ON sa.subject_id = t.id
LEFT JOIN tbl_subjects_teacher_access as sta
        ON sta.subject_id = t.id
WHERE t.id = ?
LIMIT 1
`

type GetSubjectByIdRow struct {
	Subject              Subject
	SubjectTeacherAccess SubjectTeacherAccess
}

func (q *Queries) GetSubjectById(ctx context.Context, id int64) (GetSubjectByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getSubjectById, id)
	var i GetSubjectByIdRow
	err := row.Scan(
		&i.Subject.ID,
		&i.Subject.Name,
		&i.Subject.ShortCode,
		&i.Subject.IsActive,
		&i.Subject.IsUniversal,
		&i.Subject.MajorID,
		&i.Subject.SchoolID,
		&i.Subject.SemesterID,
		&i.Subject.CreatedAt,
		&i.Subject.UpdatedAt,
		&i.SubjectTeacherAccess.ID,
		&i.SubjectTeacherAccess.SubjectID,
		&i.SubjectTeacherAccess.SchoolID,
		&i.SubjectTeacherAccess.TeacherID,
	)
	return i, err
}

const getSubjectByShortCode = `-- name: GetSubjectByShortCode :one
SELECT t.id, t.name, t.short_code, t.is_active, t.is_universal, t.major_id, t.school_id, t.semester_id, t.created_at, t.updated_at, sta.id, sta.subject_id, sta.school_id, sta.teacher_id FROM tbl_subjects as t
LEFT JOIN tbl_subjects_access as sa
    ON sa.subject_id = t.id
LEFT JOIN tbl_subjects_teacher_access as sta
        ON sta.subject_id = t.id
WHERE t.short_code = ? AND t.semester_id = ? AND t.school_id = ?
LIMIT 1
`

type GetSubjectByShortCodeParams struct {
	ShortCode  string
	SemesterID int64
	SchoolID   int64
}

type GetSubjectByShortCodeRow struct {
	Subject              Subject
	SubjectTeacherAccess SubjectTeacherAccess
}

func (q *Queries) GetSubjectByShortCode(ctx context.Context, arg GetSubjectByShortCodeParams) (GetSubjectByShortCodeRow, error) {
	row := q.db.QueryRowContext(ctx, getSubjectByShortCode, arg.ShortCode, arg.SemesterID, arg.SchoolID)
	var i GetSubjectByShortCodeRow
	err := row.Scan(
		&i.Subject.ID,
		&i.Subject.Name,
		&i.Subject.ShortCode,
		&i.Subject.IsActive,
		&i.Subject.IsUniversal,
		&i.Subject.MajorID,
		&i.Subject.SchoolID,
		&i.Subject.SemesterID,
		&i.Subject.CreatedAt,
		&i.Subject.UpdatedAt,
		&i.SubjectTeacherAccess.ID,
		&i.SubjectTeacherAccess.SubjectID,
		&i.SubjectTeacherAccess.SchoolID,
		&i.SubjectTeacherAccess.TeacherID,
	)
	return i, err
}

const getTeacherById = `-- name: GetTeacherById :one
SELECT teacher.id, teacher.name, teacher.national_teacher_id, teacher.school_id, teacher.user_id, teacher.semester_id, teacher.created_at, teacher.updated_at, user.id, user.name, user.is_active, user.email, user.password, user.user_access_id, user.user_student_id, user.user_teacher_id, user.school_id, user.created_at, user.updated_at
FROM tbl_users_teachers AS teacher
LEFT JOIN tbl_users AS user
    ON user.id = teacher.user_id
WHERE teacher.semester_id = ?
    AND teacher.school_id = ?
    AND teacher.id = ?
LIMIT 1
`

type GetTeacherByIdParams struct {
	SemesterID int64
	SchoolID   int64
	ID         int64
}

type GetTeacherByIdRow struct {
	Teacher Teacher
	User    User
}

func (q *Queries) GetTeacherById(ctx context.Context, arg GetTeacherByIdParams) (GetTeacherByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getTeacherById, arg.SemesterID, arg.SchoolID, arg.ID)
	var i GetTeacherByIdRow
	err := row.Scan(
		&i.Teacher.ID,
		&i.Teacher.Name,
		&i.Teacher.NationalTeacherID,
		&i.Teacher.SchoolID,
		&i.Teacher.UserID,
		&i.Teacher.SemesterID,
		&i.Teacher.CreatedAt,
		&i.Teacher.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.IsActive,
		&i.User.Email,
		&i.User.Password,
		&i.User.UserAccessID,
		&i.User.UserStudentID,
		&i.User.UserTeacherID,
		&i.User.SchoolID,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT user.id, user.name, user.is_active, user.email, user.password, user.user_access_id, user.user_student_id, user.user_teacher_id, user.school_id, user.created_at, user.updated_at, student.id, student.name, student.national_student_id, student.school_student_id, student.religion, student.user_id, student.school_id, student.class_id, student.semester_id, student.created_at, student.updated_at, teacher.id, teacher.name, teacher.national_teacher_id, teacher.school_id, teacher.user_id, teacher.semester_id, teacher.created_at, teacher.updated_at, user_access.id, user_access.user_id, user_access.school_id, user_access.is_student, user_access.is_admin, user_access.is_teacher
FROM tbl_users as user
LEFT JOIN tbl_users_students AS student
    ON student.id = user.user_student_id
LEFT JOIN tbl_users_teachers AS teacher
    ON teacher.id = user.user_teacher_id
LEFT JOIN tbl_users_access AS user_access
    ON user_access.id = user.user_access_id
WHERE user.id = ? AND user.school_id = ?
LIMIT 1
`

type GetUserByIdParams struct {
	ID       int64
	SchoolID int64
}

type GetUserByIdRow struct {
	User       User
	Student    Student
	Teacher    Teacher
	UserAccess UserAccess
}

func (q *Queries) GetUserById(ctx context.Context, arg GetUserByIdParams) (GetUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getUserById, arg.ID, arg.SchoolID)
	var i GetUserByIdRow
	err := row.Scan(
		&i.User.ID,
		&i.User.Name,
		&i.User.IsActive,
		&i.User.Email,
		&i.User.Password,
		&i.User.UserAccessID,
		&i.User.UserStudentID,
		&i.User.UserTeacherID,
		&i.User.SchoolID,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.Student.ID,
		&i.Student.Name,
		&i.Student.NationalStudentID,
		&i.Student.SchoolStudentID,
		&i.Student.Religion,
		&i.Student.UserID,
		&i.Student.SchoolID,
		&i.Student.ClassID,
		&i.Student.SemesterID,
		&i.Student.CreatedAt,
		&i.Student.UpdatedAt,
		&i.Teacher.ID,
		&i.Teacher.Name,
		&i.Teacher.NationalTeacherID,
		&i.Teacher.SchoolID,
		&i.Teacher.UserID,
		&i.Teacher.SemesterID,
		&i.Teacher.CreatedAt,
		&i.Teacher.UpdatedAt,
		&i.UserAccess.ID,
		&i.UserAccess.UserID,
		&i.UserAccess.SchoolID,
		&i.UserAccess.IsStudent,
		&i.UserAccess.IsAdmin,
		&i.UserAccess.IsTeacher,
	)
	return i, err
}

const listActiveSubject = `-- name: ListActiveSubject :many
SELECT id, name, short_code, is_active, is_universal, major_id, school_id, semester_id, created_at, updated_at FROM tbl_subjects
WHERE semester_id = ? AND school_id = ? AND is_active = 1
ORDER BY name
`

type ListActiveSubjectParams struct {
	SemesterID int64
	SchoolID   int64
}

func (q *Queries) ListActiveSubject(ctx context.Context, arg ListActiveSubjectParams) ([]Subject, error) {
	rows, err := q.db.QueryContext(ctx, listActiveSubject, arg.SemesterID, arg.SchoolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subject
	for rows.Next() {
		var i Subject
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortCode,
			&i.IsActive,
			&i.IsUniversal,
			&i.MajorID,
			&i.SchoolID,
			&i.SemesterID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuthLog = `-- name: ListAuthLog :many




SELECT id, user_id, client_ip, client_useragent, school_id, created_at, updated_at
FROM tbl_auth_logs
WHERE school_id = ?
ORDER BY id
`

// ======================= END TABLE TEACHERS ============================
// ======================= TABLE AUTH LOGS ============================
func (q *Queries) ListAuthLog(ctx context.Context, schoolID int64) ([]AuthLog, error) {
	rows, err := q.db.QueryContext(ctx, listAuthLog, schoolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuthLog
	for rows.Next() {
		var i AuthLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ClientIp,
			&i.ClientUseragent,
			&i.SchoolID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClass = `-- name: ListClass :many




SELECT id, name, grade_level, students_count, major_id, semester_id, school_id, homeroom_teacher_id, created_at, updated_at FROM tbl_classes
WHERE semester_id = ? AND school_id = ?
ORDER BY name
`

type ListClassParams struct {
	SemesterID int64
	SchoolID   int64
}

// ======================= END TABLE MAJORS ============================
// ======================= TABLE CLASSES ============================
func (q *Queries) ListClass(ctx context.Context, arg ListClassParams) ([]Class, error) {
	rows, err := q.db.QueryContext(ctx, listClass, arg.SemesterID, arg.SchoolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Class
	for rows.Next() {
		var i Class
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.GradeLevel,
			&i.StudentsCount,
			&i.MajorID,
			&i.SemesterID,
			&i.SchoolID,
			&i.HomeroomTeacherID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClassByGradeLevel = `-- name: ListClassByGradeLevel :many
SELECT id, name, grade_level, students_count, major_id, semester_id, school_id, homeroom_teacher_id, created_at, updated_at FROM tbl_classes
WHERE grade_level = ?
    AND semester_id = ?
    AND school_id = ?
ORDER BY name
`

type ListClassByGradeLevelParams struct {
	GradeLevel int32
	SemesterID int64
	SchoolID   int64
}

func (q *Queries) ListClassByGradeLevel(ctx context.Context, arg ListClassByGradeLevelParams) ([]Class, error) {
	rows, err := q.db.QueryContext(ctx, listClassByGradeLevel, arg.GradeLevel, arg.SemesterID, arg.SchoolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Class
	for rows.Next() {
		var i Class
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.GradeLevel,
			&i.StudentsCount,
			&i.MajorID,
			&i.SemesterID,
			&i.SchoolID,
			&i.HomeroomTeacherID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClassByMajorId = `-- name: ListClassByMajorId :many
SELECT id, name, grade_level, students_count, major_id, semester_id, school_id, homeroom_teacher_id, created_at, updated_at FROM tbl_classes
WHERE semester_id = ? AND school_id = ? AND major_id = ?
ORDER BY name
`

type ListClassByMajorIdParams struct {
	SemesterID int64
	SchoolID   int64
	MajorID    int64
}

func (q *Queries) ListClassByMajorId(ctx context.Context, arg ListClassByMajorIdParams) ([]Class, error) {
	rows, err := q.db.QueryContext(ctx, listClassByMajorId, arg.SemesterID, arg.SchoolID, arg.MajorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Class
	for rows.Next() {
		var i Class
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.GradeLevel,
			&i.StudentsCount,
			&i.MajorID,
			&i.SemesterID,
			&i.SchoolID,
			&i.HomeroomTeacherID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMajor = `-- name: ListMajor :many




SELECT id, name, short_code, school_id, created_at, updated_at FROM tbl_majors
WHERE school_id = ?
ORDER BY name
`

// ======================= END TABLE SEMESTERS ============================ --
// ======================= TABLE MAJORS ============================
func (q *Queries) ListMajor(ctx context.Context, schoolID int64) ([]Major, error) {
	rows, err := q.db.QueryContext(ctx, listMajor, schoolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Major
	for rows.Next() {
		var i Major
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortCode,
			&i.SchoolID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchool = `-- name: ListSchool :many

SELECT id, name, short_code, school_national_id, is_active, address, latitude, longitude, headmaster_name, headmaster_id, website, email, logo_url, app_name, created_at, updated_at FROM tbl_schools
ORDER BY name
`

// ======================= TABLE SCHOOLS ============================ --
func (q *Queries) ListSchool(ctx context.Context) ([]School, error) {
	rows, err := q.db.QueryContext(ctx, listSchool)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []School
	for rows.Next() {
		var i School
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortCode,
			&i.SchoolNationalID,
			&i.IsActive,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.HeadmasterName,
			&i.HeadmasterID,
			&i.Website,
			&i.Email,
			&i.LogoUrl,
			&i.AppName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchoolOnlyShortCodes = `-- name: ListSchoolOnlyShortCodes :many
SELECT short_code FROM tbl_schools
ORDER BY created_at
`

func (q *Queries) ListSchoolOnlyShortCodes(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listSchoolOnlyShortCodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var short_code string
		if err := rows.Scan(&short_code); err != nil {
			return nil, err
		}
		items = append(items, short_code)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSemester = `-- name: ListSemester :many
SELECT s.id, s.name, s.cycle, s.year, s.is_active, s.school_id, s.created_at, s.updated_at, ss.id, ss.name, ss.short_code, ss.school_national_id, ss.is_active, ss.address, ss.latitude, ss.longitude, ss.headmaster_name, ss.headmaster_id, ss.website, ss.email, ss.logo_url, ss.app_name, ss.created_at, ss.updated_at FROM tbl_semesters as s
INNER JOIN tbl_schools as ss ON ss.id = s.school_id
WHERE s.school_id = ? AND s.is_active = ?
ORDER BY ss.name
`

type ListSemesterParams struct {
	SchoolID int64
	IsActive int32
}

type ListSemesterRow struct {
	Semester Semester
	School   School
}

func (q *Queries) ListSemester(ctx context.Context, arg ListSemesterParams) ([]ListSemesterRow, error) {
	rows, err := q.db.QueryContext(ctx, listSemester, arg.SchoolID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSemesterRow
	for rows.Next() {
		var i ListSemesterRow
		if err := rows.Scan(
			&i.Semester.ID,
			&i.Semester.Name,
			&i.Semester.Cycle,
			&i.Semester.Year,
			&i.Semester.IsActive,
			&i.Semester.SchoolID,
			&i.Semester.CreatedAt,
			&i.Semester.UpdatedAt,
			&i.School.ID,
			&i.School.Name,
			&i.School.ShortCode,
			&i.School.SchoolNationalID,
			&i.School.IsActive,
			&i.School.Address,
			&i.School.Latitude,
			&i.School.Longitude,
			&i.School.HeadmasterName,
			&i.School.HeadmasterID,
			&i.School.Website,
			&i.School.Email,
			&i.School.LogoUrl,
			&i.School.AppName,
			&i.School.CreatedAt,
			&i.School.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStudent = `-- name: ListStudent :many




SELECT student.id, student.name, student.national_student_id, student.school_student_id, student.religion, student.user_id, student.school_id, student.class_id, student.semester_id, student.created_at, student.updated_at, user.id, user.name, user.is_active, user.email, user.password, user.user_access_id, user.user_student_id, user.user_teacher_id, user.school_id, user.created_at, user.updated_at, class.id, class.name, class.grade_level, class.students_count, class.major_id, class.semester_id, class.school_id, class.homeroom_teacher_id, class.created_at, class.updated_at
FROM tbl_users_students as student
LEFT JOIN tbl_users AS user
    ON user.user_student_id = student.id
LEFT JOIN tbl_classes AS class
    ON class.id = student.class_id
WHERE student.school_id = ?
    AND student.semester_id = ?
ORDER BY student.id
`

type ListStudentParams struct {
	SchoolID   int64
	SemesterID int64
}

type ListStudentRow struct {
	Student Student
	User    User
	Class   Class
}

// ======================= END TABLE USERS ============================
// ======================= TABLE STUDENTS ============================
func (q *Queries) ListStudent(ctx context.Context, arg ListStudentParams) ([]ListStudentRow, error) {
	rows, err := q.db.QueryContext(ctx, listStudent, arg.SchoolID, arg.SemesterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStudentRow
	for rows.Next() {
		var i ListStudentRow
		if err := rows.Scan(
			&i.Student.ID,
			&i.Student.Name,
			&i.Student.NationalStudentID,
			&i.Student.SchoolStudentID,
			&i.Student.Religion,
			&i.Student.UserID,
			&i.Student.SchoolID,
			&i.Student.ClassID,
			&i.Student.SemesterID,
			&i.Student.CreatedAt,
			&i.Student.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.IsActive,
			&i.User.Email,
			&i.User.Password,
			&i.User.UserAccessID,
			&i.User.UserStudentID,
			&i.User.UserTeacherID,
			&i.User.SchoolID,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.Class.ID,
			&i.Class.Name,
			&i.Class.GradeLevel,
			&i.Class.StudentsCount,
			&i.Class.MajorID,
			&i.Class.SemesterID,
			&i.Class.SchoolID,
			&i.Class.HomeroomTeacherID,
			&i.Class.CreatedAt,
			&i.Class.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubject = `-- name: ListSubject :many



SELECT id, name, short_code, is_active, is_universal, major_id, school_id, semester_id, created_at, updated_at FROM tbl_subjects
WHERE semester_id = ? AND school_id = ?
ORDER BY name
`

type ListSubjectParams struct {
	SemesterID int64
	SchoolID   int64
}

// ======================= END TABLE CLASSES ============================
// ======================= TABLE SUBJECTS ============================
func (q *Queries) ListSubject(ctx context.Context, arg ListSubjectParams) ([]Subject, error) {
	rows, err := q.db.QueryContext(ctx, listSubject, arg.SemesterID, arg.SchoolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subject
	for rows.Next() {
		var i Subject
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortCode,
			&i.IsActive,
			&i.IsUniversal,
			&i.MajorID,
			&i.SchoolID,
			&i.SemesterID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubjectByMajor = `-- name: ListSubjectByMajor :many
SELECT id, name, short_code, is_active, is_universal, major_id, school_id, semester_id, created_at, updated_at FROM tbl_subjects
WHERE semester_id = ? AND school_id = ? AND major_id = ?
ORDER BY name
`

type ListSubjectByMajorParams struct {
	SemesterID int64
	SchoolID   int64
	MajorID    int64
}

func (q *Queries) ListSubjectByMajor(ctx context.Context, arg ListSubjectByMajorParams) ([]Subject, error) {
	rows, err := q.db.QueryContext(ctx, listSubjectByMajor, arg.SemesterID, arg.SchoolID, arg.MajorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subject
	for rows.Next() {
		var i Subject
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortCode,
			&i.IsActive,
			&i.IsUniversal,
			&i.MajorID,
			&i.SchoolID,
			&i.SemesterID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeacher = `-- name: ListTeacher :many



SELECT teacher.id, teacher.name, teacher.national_teacher_id, teacher.school_id, teacher.user_id, teacher.semester_id, teacher.created_at, teacher.updated_at, user.id, user.name, user.is_active, user.email, user.password, user.user_access_id, user.user_student_id, user.user_teacher_id, user.school_id, user.created_at, user.updated_at
FROM tbl_users_teachers AS teacher
LEFT JOIN tbl_users AS user
    ON user.id = teacher.user_id
WHERE teacher.semester_id = ?
    AND teacher.school_id = ?
ORDER BY teacher.id
`

type ListTeacherParams struct {
	SemesterID int64
	SchoolID   int64
}

type ListTeacherRow struct {
	Teacher Teacher
	User    User
}

// ======================= END TABLE STUDENTS ============================
// ======================= TABLE TEACHERS ============================
func (q *Queries) ListTeacher(ctx context.Context, arg ListTeacherParams) ([]ListTeacherRow, error) {
	rows, err := q.db.QueryContext(ctx, listTeacher, arg.SemesterID, arg.SchoolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTeacherRow
	for rows.Next() {
		var i ListTeacherRow
		if err := rows.Scan(
			&i.Teacher.ID,
			&i.Teacher.Name,
			&i.Teacher.NationalTeacherID,
			&i.Teacher.SchoolID,
			&i.Teacher.UserID,
			&i.Teacher.SemesterID,
			&i.Teacher.CreatedAt,
			&i.Teacher.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.IsActive,
			&i.User.Email,
			&i.User.Password,
			&i.User.UserAccessID,
			&i.User.UserStudentID,
			&i.User.UserTeacherID,
			&i.User.SchoolID,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUniversalSubject = `-- name: ListUniversalSubject :many
SELECT id, name, short_code, is_active, is_universal, major_id, school_id, semester_id, created_at, updated_at FROM tbl_subjects
WHERE semester_id = ? AND school_id = ? AND is_universal = 1
ORDER BY name
`

type ListUniversalSubjectParams struct {
	SemesterID int64
	SchoolID   int64
}

func (q *Queries) ListUniversalSubject(ctx context.Context, arg ListUniversalSubjectParams) ([]Subject, error) {
	rows, err := q.db.QueryContext(ctx, listUniversalSubject, arg.SemesterID, arg.SchoolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subject
	for rows.Next() {
		var i Subject
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortCode,
			&i.IsActive,
			&i.IsUniversal,
			&i.MajorID,
			&i.SchoolID,
			&i.SemesterID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUser = `-- name: ListUser :many



SELECT user.id, user.name, user.is_active, user.email, user.password, user.user_access_id, user.user_student_id, user.user_teacher_id, user.school_id, user.created_at, user.updated_at, student.id, student.name, student.national_student_id, student.school_student_id, student.religion, student.user_id, student.school_id, student.class_id, student.semester_id, student.created_at, student.updated_at, teacher.id, teacher.name, teacher.national_teacher_id, teacher.school_id, teacher.user_id, teacher.semester_id, teacher.created_at, teacher.updated_at, user_access.id, user_access.user_id, user_access.school_id, user_access.is_student, user_access.is_admin, user_access.is_teacher
FROM tbl_users as user
LEFT JOIN tbl_users_students AS student
    ON student.id = user.user_student_id
LEFT JOIN tbl_users_teachers AS teacher
    ON teacher.id = user.user_teacher_id
LEFT JOIN tbl_users_access AS user_access
    ON user_access.id = user.user_access_id
WHERE user.school_id = ?
ORDER BY user.id
`

type ListUserRow struct {
	User       User
	Student    Student
	Teacher    Teacher
	UserAccess UserAccess
}

// ======================= END TABLE SUBJECTS ============================
// ======================== TABLE USERS ============================
func (q *Queries) ListUser(ctx context.Context, schoolID int64) ([]ListUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listUser, schoolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserRow
	for rows.Next() {
		var i ListUserRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Name,
			&i.User.IsActive,
			&i.User.Email,
			&i.User.Password,
			&i.User.UserAccessID,
			&i.User.UserStudentID,
			&i.User.UserTeacherID,
			&i.User.SchoolID,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.Student.ID,
			&i.Student.Name,
			&i.Student.NationalStudentID,
			&i.Student.SchoolStudentID,
			&i.Student.Religion,
			&i.Student.UserID,
			&i.Student.SchoolID,
			&i.Student.ClassID,
			&i.Student.SemesterID,
			&i.Student.CreatedAt,
			&i.Student.UpdatedAt,
			&i.Teacher.ID,
			&i.Teacher.Name,
			&i.Teacher.NationalTeacherID,
			&i.Teacher.SchoolID,
			&i.Teacher.UserID,
			&i.Teacher.SemesterID,
			&i.Teacher.CreatedAt,
			&i.Teacher.UpdatedAt,
			&i.UserAccess.ID,
			&i.UserAccess.UserID,
			&i.UserAccess.SchoolID,
			&i.UserAccess.IsStudent,
			&i.UserAccess.IsAdmin,
			&i.UserAccess.IsTeacher,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerClass = `-- name: RegisterClass :execresult
INSERT INTO tbl_classes (
    name,
    grade_level,
    students_count,
    major_id,
    semester_id,
    school_id
) VALUES (
    ?,
    ?,
    0,
    ?,
    ?,
    ?
)
`

type RegisterClassParams struct {
	Name       string
	GradeLevel int32
	MajorID    int64
	SemesterID int64
	SchoolID   int64
}

func (q *Queries) RegisterClass(ctx context.Context, arg RegisterClassParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, registerClass,
		arg.Name,
		arg.GradeLevel,
		arg.MajorID,
		arg.SemesterID,
		arg.SchoolID,
	)
}

const registerMajor = `-- name: RegisterMajor :execresult
INSERT INTO tbl_majors (
    name,
    short_code,
    school_id
) VALUES (
    ?,
    ?,
    ?
)
`

type RegisterMajorParams struct {
	Name      string
	ShortCode string
	SchoolID  int64
}

func (q *Queries) RegisterMajor(ctx context.Context, arg RegisterMajorParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, registerMajor, arg.Name, arg.ShortCode, arg.SchoolID)
}

const registerSchool = `-- name: RegisterSchool :execresult
INSERT INTO tbl_schools (
    name,
    short_code,
    school_national_id,
    address,
    latitude,
    longitude,
    headmaster_name,
    headmaster_id,
    website,
    email,
    app_name
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type RegisterSchoolParams struct {
	SchoolName       string
	ShortCode        string
	SchoolNationalID string
	Address          sql.NullString
	Latitude         sql.NullString
	Longitude        sql.NullString
	HeadmasterName   string
	HeadmasterID     string
	Website          sql.NullString
	Email            sql.NullString
	AppName          string
}

func (q *Queries) RegisterSchool(ctx context.Context, arg RegisterSchoolParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, registerSchool,
		arg.SchoolName,
		arg.ShortCode,
		arg.SchoolNationalID,
		arg.Address,
		arg.Latitude,
		arg.Longitude,
		arg.HeadmasterName,
		arg.HeadmasterID,
		arg.Website,
		arg.Email,
		arg.AppName,
	)
}

const registerStudent = `-- name: RegisterStudent :execresult
INSERT INTO tbl_users_students (
    name,
    national_student_id,
    school_student_id,
    religion,

    user_id,
    school_id,
    semester_id,
    class_id
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type RegisterStudentParams struct {
	Name              string
	NationalStudentID string
	SchoolStudentID   string
	Religion          Religion
	UserID            int64
	SchoolID          int64
	SemesterID        int64
	ClassID           sql.NullInt64
}

func (q *Queries) RegisterStudent(ctx context.Context, arg RegisterStudentParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, registerStudent,
		arg.Name,
		arg.NationalStudentID,
		arg.SchoolStudentID,
		arg.Religion,
		arg.UserID,
		arg.SchoolID,
		arg.SemesterID,
		arg.ClassID,
	)
}

const registerTeacher = `-- name: RegisterTeacher :execresult
INSERT INTO tbl_users_teachers (
    name,
    national_teacher_id,
    school_id,
    user_id,
    semester_id
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type RegisterTeacherParams struct {
	Name              string
	NationalTeacherID string
	SchoolID          int64
	UserID            int64
	SemesterID        int64
}

func (q *Queries) RegisterTeacher(ctx context.Context, arg RegisterTeacherParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, registerTeacher,
		arg.Name,
		arg.NationalTeacherID,
		arg.SchoolID,
		arg.UserID,
		arg.SemesterID,
	)
}

const registerUser = `-- name: RegisterUser :execresult
INSERT INTO tbl_users (
    name,
    is_active,
    email,
    school_id,
    password
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type RegisterUserParams struct {
	Username string
	IsActive sql.NullInt32
	Email    string
	SchoolID int64
	Password string
}

func (q *Queries) RegisterUser(ctx context.Context, arg RegisterUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, registerUser,
		arg.Username,
		arg.IsActive,
		arg.Email,
		arg.SchoolID,
		arg.Password,
	)
}

const searchSchoolByName = `-- name: SearchSchoolByName :many
SELECT id, name, short_code, school_national_id, is_active, address, latitude, longitude, headmaster_name, headmaster_id, website, email, logo_url, app_name, created_at, updated_at FROM tbl_schools
WHERE name LIKE ?
`

func (q *Queries) SearchSchoolByName(ctx context.Context, name string) ([]School, error) {
	rows, err := q.db.QueryContext(ctx, searchSchoolByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []School
	for rows.Next() {
		var i School
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortCode,
			&i.SchoolNationalID,
			&i.IsActive,
			&i.Address,
			&i.Latitude,
			&i.Longitude,
			&i.HeadmasterName,
			&i.HeadmasterID,
			&i.Website,
			&i.Email,
			&i.LogoUrl,
			&i.AppName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchStudent = `-- name: SearchStudent :many
SELECT student.id, student.name, student.national_student_id, student.school_student_id, student.religion, student.user_id, student.school_id, student.class_id, student.semester_id, student.created_at, student.updated_at, user.id, user.name, user.is_active, user.email, user.password, user.user_access_id, user.user_student_id, user.user_teacher_id, user.school_id, user.created_at, user.updated_at, class.id, class.name, class.grade_level, class.students_count, class.major_id, class.semester_id, class.school_id, class.homeroom_teacher_id, class.created_at, class.updated_at
FROM tbl_users_students as student
LEFT JOIN tbl_users AS user
    ON user.user_student_id = student.id
LEFT JOIN tbl_classes AS class
    ON class.id = student.class_id
WHERE student.school_id = ?
    AND student.semester_id = ?
    AND (
        student.name LIKE ?
        OR student.national_student_id LIKE ?
        OR student.school_student_id LIKE ?
    )
ORDER BY student.id
`

type SearchStudentParams struct {
	SchoolID   int64
	SemesterID int64
	Query      string
}

type SearchStudentRow struct {
	Student Student
	User    User
	Class   Class
}

func (q *Queries) SearchStudent(ctx context.Context, arg SearchStudentParams) ([]SearchStudentRow, error) {
	rows, err := q.db.QueryContext(ctx, searchStudent,
		arg.SchoolID,
		arg.SemesterID,
		arg.Query,
		arg.Query,
		arg.Query,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchStudentRow
	for rows.Next() {
		var i SearchStudentRow
		if err := rows.Scan(
			&i.Student.ID,
			&i.Student.Name,
			&i.Student.NationalStudentID,
			&i.Student.SchoolStudentID,
			&i.Student.Religion,
			&i.Student.UserID,
			&i.Student.SchoolID,
			&i.Student.ClassID,
			&i.Student.SemesterID,
			&i.Student.CreatedAt,
			&i.Student.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.IsActive,
			&i.User.Email,
			&i.User.Password,
			&i.User.UserAccessID,
			&i.User.UserStudentID,
			&i.User.UserTeacherID,
			&i.User.SchoolID,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.Class.ID,
			&i.Class.Name,
			&i.Class.GradeLevel,
			&i.Class.StudentsCount,
			&i.Class.MajorID,
			&i.Class.SemesterID,
			&i.Class.SchoolID,
			&i.Class.HomeroomTeacherID,
			&i.Class.CreatedAt,
			&i.Class.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTeacher = `-- name: SearchTeacher :many
SELECT id, name, national_teacher_id, school_id, user_id, semester_id, created_at, updated_at
FROM tbl_users_teachers
WHERE name LIKE ?
    OR national_teacher_id LIKE ?
    AND school_id = ?
    AND semester_id = ?
ORDER BY teacher.id
`

type SearchTeacherParams struct {
	Query      string
	SchoolID   int64
	SemesterID int64
}

func (q *Queries) SearchTeacher(ctx context.Context, arg SearchTeacherParams) ([]Teacher, error) {
	rows, err := q.db.QueryContext(ctx, searchTeacher,
		arg.Query,
		arg.Query,
		arg.SchoolID,
		arg.SemesterID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Teacher
	for rows.Next() {
		var i Teacher
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NationalTeacherID,
			&i.SchoolID,
			&i.UserID,
			&i.SemesterID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUser = `-- name: SearchUser :many
SELECT id, name, is_active, email, password, user_access_id, user_student_id, user_teacher_id, school_id, created_at, updated_at FROM tbl_users as user
WHERE user.name LIKE ?
    OR user.email LIKE ?
    AND user.school_id = ?
ORDER BY user.id
`

type SearchUserParams struct {
	Query    string
	SchoolID int64
}

func (q *Queries) SearchUser(ctx context.Context, arg SearchUserParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, searchUser, arg.Query, arg.Query, arg.SchoolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsActive,
			&i.Email,
			&i.Password,
			&i.UserAccessID,
			&i.UserStudentID,
			&i.UserTeacherID,
			&i.SchoolID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateActiveSemester = `-- name: UpdateActiveSemester :exec
UPDATE tbl_semesters SET is_active = 1
WHERE id = ? AND school_id = ?
`

type UpdateActiveSemesterParams struct {
	ID       int64
	SchoolID int64
}

func (q *Queries) UpdateActiveSemester(ctx context.Context, arg UpdateActiveSemesterParams) error {
	_, err := q.db.ExecContext(ctx, updateActiveSemester, arg.ID, arg.SchoolID)
	return err
}

const updateClass = `-- name: UpdateClass :exec
UPDATE tbl_classes
SET name = CASE WHEN ? IS NOT NULL
    THEN ?
    ELSE name
END,
    grade_level = CASE WHEN ? IS NOT NULL
    THEN ?
    ELSE grade_level
END,
    major_id = CASE WHEN ? IS NOT NULL
    THEN ?
    ELSE major_id
END,
    homeroom_teacher_id = CASE WHEN ? IS NOT NULL
    THEN ?
    ELSE homeroom_teacher_id
END,
    updated_at = NOW()
WHERE semester_id = ? AND school_id = ?
`

type UpdateClassParams struct {
	NewName              sql.NullString
	NewLevel             sql.NullInt32
	NewMajorID           sql.NullInt64
	NewHomeroomTeacherID sql.NullInt64
	SemesterID           int64
	SchoolID             int64
}

func (q *Queries) UpdateClass(ctx context.Context, arg UpdateClassParams) error {
	_, err := q.db.ExecContext(ctx, updateClass,
		arg.NewName,
		arg.NewName,
		arg.NewLevel,
		arg.NewLevel,
		arg.NewMajorID,
		arg.NewMajorID,
		arg.NewHomeroomTeacherID,
		arg.NewHomeroomTeacherID,
		arg.SemesterID,
		arg.SchoolID,
	)
	return err
}

const updateMajorById = `-- name: UpdateMajorById :exec
UPDATE tbl_majors
SET name = CASE WHEN ? IS NOT NULL
    THEN ?
    ELSE name
END,
    short_code = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE short_code
END
WHERE id = ?
`

type UpdateMajorByIdParams struct {
	NewName      sql.NullString
	NewShortCode sql.NullString
	ID           int64
}

func (q *Queries) UpdateMajorById(ctx context.Context, arg UpdateMajorByIdParams) error {
	_, err := q.db.ExecContext(ctx, updateMajorById,
		arg.NewName,
		arg.NewName,
		arg.NewShortCode,
		arg.NewShortCode,
		arg.ID,
	)
	return err
}

const updateMajorByShortCode = `-- name: UpdateMajorByShortCode :exec
UPDATE tbl_majors
SET name = CASE WHEN ? IS NOT NULL
    THEN ?
    ELSE name
END,
    short_code = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE short_code
END
WHERE short_code = ? AND school_id = ?
`

type UpdateMajorByShortCodeParams struct {
	NewName      sql.NullString
	NewShortCode sql.NullString
	ShortCode    string
	SchoolID     int64
}

func (q *Queries) UpdateMajorByShortCode(ctx context.Context, arg UpdateMajorByShortCodeParams) error {
	_, err := q.db.ExecContext(ctx, updateMajorByShortCode,
		arg.NewName,
		arg.NewName,
		arg.NewShortCode,
		arg.NewShortCode,
		arg.ShortCode,
		arg.SchoolID,
	)
	return err
}

const updateSchoolById = `-- name: UpdateSchoolById :exec
UPDATE tbl_schools
SET
    name = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE name
    END,
    
    school_national_id = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE school_national_id
    END,

    address = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE address
    END,

    latitude = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE latitude
    END,

    longitude = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE longitude
    END,

    headmaster_name = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE headmaster_name
    END,

    headmaster_id = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE headmaster_id
    END,

    website = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE website
    END,

    email = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE email
    END,

    logo_url = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE logo_url
    END,

    app_name = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE app_name
    END,

    updated_at = NOW()
WHERE id = ?
`

type UpdateSchoolByIdParams struct {
	NewName             sql.NullString
	NewSchoolNationalID sql.NullString
	NewAddress          sql.NullString
	NewLatitude         sql.NullString
	NewLongitude        sql.NullString
	NewHeadmasterName   sql.NullString
	NewHeadmasterID     sql.NullString
	NewWebsite          sql.NullString
	NewEmail            sql.NullString
	NewLogoUrl          sql.NullString
	NewAppName          sql.NullString
	ID                  int64
}

func (q *Queries) UpdateSchoolById(ctx context.Context, arg UpdateSchoolByIdParams) error {
	_, err := q.db.ExecContext(ctx, updateSchoolById,
		arg.NewName,
		arg.NewName,
		arg.NewSchoolNationalID,
		arg.NewSchoolNationalID,
		arg.NewAddress,
		arg.NewAddress,
		arg.NewLatitude,
		arg.NewLatitude,
		arg.NewLongitude,
		arg.NewLongitude,
		arg.NewHeadmasterName,
		arg.NewHeadmasterName,
		arg.NewHeadmasterID,
		arg.NewHeadmasterID,
		arg.NewWebsite,
		arg.NewWebsite,
		arg.NewEmail,
		arg.NewEmail,
		arg.NewLogoUrl,
		arg.NewLogoUrl,
		arg.NewAppName,
		arg.NewAppName,
		arg.ID,
	)
	return err
}

const updateStudent = `-- name: UpdateStudent :exec
UPDATE tbl_users_students
SET
    name = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE name
    END,

    national_student_id = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE national_student_id
    END,

    school_student_id = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE school_student_id
    END,

    religion = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE religion
    END,

    class_id = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE class_id
    END,

    updated_at = NOW()
WHERE id = ?
`

type UpdateStudentParams struct {
	NewName              sql.NullString
	NewNationalStudentID sql.NullString
	NewSchoolStudentID   sql.NullString
	NewReligion          NullReligion
	NewClassID           sql.NullInt64
	ID                   int64
}

func (q *Queries) UpdateStudent(ctx context.Context, arg UpdateStudentParams) error {
	_, err := q.db.ExecContext(ctx, updateStudent,
		arg.NewName,
		arg.NewName,
		arg.NewNationalStudentID,
		arg.NewNationalStudentID,
		arg.NewSchoolStudentID,
		arg.NewSchoolStudentID,
		arg.NewReligion,
		arg.NewReligion,
		arg.NewClassID,
		arg.NewClassID,
		arg.ID,
	)
	return err
}

const updateTeacher = `-- name: UpdateTeacher :exec
UPDATE tbl_users_teachers
SET
    name = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE name
    END,

    national_teacher_id = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE national_teacher_id
    END,

    updated_at = NOW()
WHERE id = ?
`

type UpdateTeacherParams struct {
	NewName              sql.NullString
	NewNationalTeacherID sql.NullString
	ID                   int64
}

func (q *Queries) UpdateTeacher(ctx context.Context, arg UpdateTeacherParams) error {
	_, err := q.db.ExecContext(ctx, updateTeacher,
		arg.NewName,
		arg.NewName,
		arg.NewNationalTeacherID,
		arg.NewNationalTeacherID,
		arg.ID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE tbl_users
SET
    name = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE name
    END,

    email = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE email
    END,

    password = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE password
    END,

    user_access_id = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE user_access_id
    END,

    user_student_id = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE user_student_id
    END,

    user_teacher_id = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE user_teacher_id
    END,
    
    updated_at = NOW()
WHERE id = ?
`

type UpdateUserParams struct {
	NewName          sql.NullString
	NewEmail         sql.NullString
	NewPassword      sql.NullString
	NewUserAccessID  sql.NullInt64
	NewUserStudentID sql.NullInt64
	NewUserTeacherID sql.NullInt64
	ID               int64
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.NewName,
		arg.NewName,
		arg.NewEmail,
		arg.NewEmail,
		arg.NewPassword,
		arg.NewPassword,
		arg.NewUserAccessID,
		arg.NewUserAccessID,
		arg.NewUserStudentID,
		arg.NewUserStudentID,
		arg.NewUserTeacherID,
		arg.NewUserTeacherID,
		arg.ID,
	)
	return err
}

const updateUserAccess = `-- name: UpdateUserAccess :exec
UPDATE tbl_users_access
SET
    is_student = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE is_student
    END,

    is_admin = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE is_admin
    END,

    is_teacher = CASE WHEN ? IS NOT NULL
        THEN ?
        ELSE is_teacher
    END
WHERE id = ?
`

type UpdateUserAccessParams struct {
	IsStudent sql.NullInt32
	IsAdmin   sql.NullInt32
	IsTeacher sql.NullInt32
	ID        int64
}

func (q *Queries) UpdateUserAccess(ctx context.Context, arg UpdateUserAccessParams) error {
	_, err := q.db.ExecContext(ctx, updateUserAccess,
		arg.IsStudent,
		arg.IsStudent,
		arg.IsAdmin,
		arg.IsAdmin,
		arg.IsTeacher,
		arg.IsTeacher,
		arg.ID,
	)
	return err
}
